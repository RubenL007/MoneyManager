@page "/Balance"
@using MoneyManager.Data.Interface
@using MoneyManager.Data.Models
@using MoneyManager.Data.Models.Balance

@inject IBalance BalanceService
@inject NavigationManager navigationManager

<DefaultHeaderComponent Title="Balance"
                        ViewMode=@ViewMode
                        EditOnClick=@(x => ViewMode = ViewMode == ViewModeEnum.View ? ViewModeEnum.Edit : ViewModeEnum.View)
                        SaveOnClick=@(x => UpdateBalances())>
</DefaultHeaderComponent>

<CardComponent @key=@Balances>
    <ChartComponent>
        <LineChartComponent ChartTitle="Balances Overview">
            <LineSeriesComponent Data=@Balances
                                 CategoryPropertyXaxis=@nameof(BalanceModel.ChartDate)
                                 ValuePropertyYaxis=@nameof(BalanceModel.TotalValue)
                                 SeriesTitle="Total"
                                 LineType=@Shared.Components.Charts.Helpers.LineTypeEnum.Solid
                                 Color=@ColorsEnum.primary />

            @foreach (var account in ChartAccounts)
            {
                <LineSeriesComponent Data=@account.AccountBalances
                                     CategoryPropertyXaxis=@nameof(ChartAccountBalanceModel.Date)
                                     ValuePropertyYaxis=@nameof(ChartAccountBalanceModel.TotalValue)
                                     SeriesTitle=@account.AccountName
                                     LineType=@Shared.Components.Charts.Helpers.LineTypeEnum.Dotted
                                     AllowMeanVisible=false
                                     AllowMedianVisible=false
                                     AllowModeVisible=false
                                     AllowTrendVisible=false/>
            }
        </LineChartComponent>
    </ChartComponent>
</CardComponent>

@if (ViewMode == ViewModeEnum.Edit)
{
    <div class="row d-flex align-items-center mt-2">
        <div class="col-auto">
            <ButtonComponent OnClick=@(x => AddNewBalance())
                             ButtonType=@ButtonTypeEnum.Add
                             DisplayName="Add New Balance"
                             ViewMode=@(Balances.Any(b => b.Date.Year == Balance.Date.Year && b.Date.Month == Balance.Date.Month) ? ViewModeEnum.View : ViewMode) />
        </div>
        <div class="col-auto">
            <EditForm Model=@Balance>
                <InputDateComponent @bind-Value=@Balance.Date
                                    ViewMode=@ViewMode />
            </EditForm>
        </div>
    </div>
}

<div class="row row-cols-lg-4 row-cols-md-6 row-cols">
    @foreach (var balance in Balances)
    {
        <div class="col">
            <CardComponent>
                <div class="row">
                    <div class="col">
                        <span class="fw-bold">@balance.Date.ToString("d")</span>
                    </div>
                    <div class="col-auto">
                        <ButtonComponent OnClick=@(() => DeleteBalance(balance))
                                         Color=@ColorsEnum.danger
                                         IconClass="oi oi-trash"
                                         Tooltip="Delete this Balance"
                                         IsVisible=@(ViewMode == ViewModeEnum.Edit ? true : false ) />
                    </div>
                </div>
                @foreach (var account in balance.Accounts)
                {
                    <EditForm Model=@account>
                        @if (ViewMode == ViewModeEnum.View)
                        {
                            <div class="row">
                                <div class="col ms-1">
                                    @account.Name
                                </div>
                                <span class="col-auto align-self-end">@account.Value</span>
                            </div>
                        }
                        else
                        {
                            <InputNumberComponent @bind-Value=@account.Value
                                                  ViewMode=@ViewMode
                                                  DisplayName=@account.Name />
                        }
                    </EditForm>
                }
                <span class="align-self-end fw-bold">Total @balance.TotalValue</span>
                <span class=@($"align-self-end balance-comparison-values text-{(ValueComparisonWithPreviousBalance(balance) > 0 ? "primary" : "danger")}")
                      title="Change relative to the previous balance.">
                    @PercentageComparisonWithPreviousBalance(balance)% | @ValueComparisonWithPreviousBalance(balance)
                </span>
            </CardComponent>
        </div>
    }
</div>

@code {
    #region Properties
    BalanceModel Balance = new();
    List<BalanceModel> Balances = new();
    List<ChartAccountModel> ChartAccounts = new();
    ViewModeEnum ViewMode = ViewModeEnum.View;
    #endregion

    #region Task OnInitializedAsync()
    protected override async Task OnInitializedAsync()
    {
        await SearchBalances();
        await base.OnInitializedAsync();
    }
    #endregion

    #region Task SearchBalances()
    private async Task SearchBalances()
    {
        Balances = BalanceService.SearchBalances();
        if (Balances.Any())
        {
            ChartAccounts.Clear();

            ChartAccounts = Balances.SelectMany(b => b.Accounts)
                                    .GroupBy(a => a.Id)
                                    .Select(g => new ChartAccountModel
                                        {
                                            AccountId = g.Key,
                                            AccountName = g.First().Name,
                                        }).ToList();

            foreach (var chartAccount in ChartAccounts)
            {
                chartAccount.AccountBalances = Balances
                    .SelectMany(b => b.Accounts
                        .Where(a => a.Id == chartAccount.AccountId)
                        .Select(a => new ChartAccountBalanceModel
                            {
                                TotalValue = a.Value,
                                Date = b.ChartDate
                            }))
                    .OrderBy(x => x.Date)
                    .ToList();
            }
        }

        StateHasChanged();
        await Task.CompletedTask;
    }
    #endregion

    #region Task AddNewBalance()
    private async Task AddNewBalance()
    {
        BalanceService.CreateBalance(Balance);
        Balances.Add(Balance);
        Balances = Balances.OrderByDescending(b => b.Date).ToList();
        DateTimeOffset previousDate = Balance.Date;
        Balance = new()
            {
                Date = previousDate
            };
        StateHasChanged();
        await Task.CompletedTask;
    }
    #endregion

    #region Task UpdateBalances()
    private async Task UpdateBalances()
    {
        foreach (var balance in Balances)
        {
            BalanceService.UpdateBalance(balance);
        }
        await SearchBalances();
        ViewMode = ViewModeEnum.View;
        await Task.CompletedTask;
    }
    #endregion

    #region Task DeleteBalance(BalanceModel balance)
    private async Task DeleteBalance(BalanceModel balance)
    {
        BalanceService.DeleteBalance(balance.Id);
        await SearchBalances();
        await Task.CompletedTask;
    }
    #endregion

    #region double PercentageComparisonWithPreviousBalance(BalanceModel currentBalance)
    private double PercentageComparisonWithPreviousBalance(BalanceModel currentBalance)
    {
        int currentBalanceIndex = Balances.IndexOf(currentBalance);
        if (currentBalanceIndex != Balances.Count - 1)
        {
            double previousTotalValue = Balances[currentBalanceIndex + 1].TotalValue;
            if (previousTotalValue == 0) return 100; //if previous 0 is increase of 100%

            double currentTotalValue = currentBalance.TotalValue;
            double difference = ((currentTotalValue - previousTotalValue) / previousTotalValue) * 100;

            //if previous is less than 0 and current greater than 0, returns positive %
            if (previousTotalValue < 0 && currentTotalValue > 0) difference = Math.Abs(difference);
            return Math.Round(difference, 2, MidpointRounding.AwayFromZero);
        }
        return 0;
    }
    #endregion

    #region double ValueComparisonWithPreviousBalance(BalanceModel currentBalance)
    private double ValueComparisonWithPreviousBalance(BalanceModel currentBalance)
    {
        int currentBalanceIndex = Balances.IndexOf(currentBalance);
        if (currentBalanceIndex != Balances.Count - 1)
        {
            double previousTotalValue = Balances[currentBalanceIndex + 1].TotalValue;

            return currentBalance.TotalValue - previousTotalValue;
        }
        return 0;
    }
    #endregion
}
