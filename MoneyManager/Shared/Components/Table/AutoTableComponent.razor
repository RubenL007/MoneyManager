@namespace MoneyManager.Shared.Components

@using System.Reflection
@using System.Text
@using MoneyManager.Data.Models

@typeparam TItem

@if (DataSource is List<MonthSheetModel> monthsheetData)
{
    <div class="row">
        <div class="col d-flex justify-content-end">
    <ExportMonthsheetButton Data=@monthsheetData  />
        </div>
    </div>
}

<table class="table">
    <thead>
        <tr>
            @if (Properties.Any())
            {
                foreach (var property in Properties)
                {
                    <th>@GetFieldName(property)</th>
                }
                if (DeleteRowMethod.HasDelegate && ViewMode == ViewModeEnum.Edit)
                {
                    <th></th>
                }
            }
            else
            {
                <th></th>
            }
        </tr>
    </thead>
    <tbody>
        @if (DataSource.Any())
        {
            foreach (var item in DataSource)
            {
                <tr>
                    @foreach (var property in Properties)
                    {
                        if (IsEditableTable && ViewMode == ViewModeEnum.Edit)
                        {
                            var propType = property.PropertyType;
                            <td>
                                <EditForm Model=property>
                                    @if (propType == typeof(DateTimeOffset))
                                    {
                                        <InputDateComponent Value=@PropertyWrapperHelper.GetDateTimeOffsetWrapper(item!, property).Value
                                                            ValueExpression=@(() => PropertyWrapperHelper.GetDateTimeOffsetWrapper(item!, property).Value)
                                                            ViewMode=@ViewMode
                                                            LimitToThisDateMonth=@(IsDateInputLimitedToDate? LimitDateInputsToThisDate : null)
                                                            ValueChanged=@(async (DateTimeOffset newValue) =>
                                                            {
                                                                // To update and notify the parent view about the change
                                                                PropertyWrapperHelper.GetDateTimeOffsetWrapper(item!, property).Value = newValue;
                                                                await OnValueChange.InvokeAsync(null);
                                                            }) />
                                    }
                                    else if (propType == typeof(DateTimeOffset?))
                                    {
                                        <InputDateComponent Value=@PropertyWrapperHelper.GetDateTimeOffsetWrapperNullable(item!, property).Value
                                                            ValueExpression=@(() => PropertyWrapperHelper.GetDateTimeOffsetWrapperNullable(item!, property).Value)
                                                            ViewMode=@ViewMode
                                                            LimitToThisDateMonth=@(IsDateInputLimitedToDate? LimitDateInputsToThisDate : null)
                                                            ValueChanged=@(async (DateTimeOffset? newValue) =>
                                                            {
                                                                // To update and notify the parent view about the change
                                                                PropertyWrapperHelper.GetDateTimeOffsetWrapperNullable(item!, property).Value = newValue;
                                                                await OnValueChange.InvokeAsync(null);
                                                            }) />
                                    }
                                    else if (propType == typeof(string))
                                    {
                                        <InputTextComponent @bind-Value=@PropertyWrapperHelper.GetStringWrapper(item!, property).Value
                                        ViewMode=@ViewMode />
                                    }
                                    else if (propType == typeof(bool))
                                    {
                                        <InputCheckBoxComponent @bind-Value=@PropertyWrapperHelper.GetBoolWrapper(item!, property).Value
                                        ViewMode=@ViewMode />
                                    }
                                    else if (propType == typeof(double))
                                    {
                                        <InputNumberComponent Value=@PropertyWrapperHelper.GetDoubleWrapper(item!, property).Value
                                                              ValueExpression=@(() => PropertyWrapperHelper.GetDoubleWrapper(item!, property).Value)
                                                              ViewMode=@ViewMode
                                                              ValueChanged=@(async (double newValue) =>
                                                              {
                                                                // To update and notify the parent view about the change
                                                                  PropertyWrapperHelper.GetDoubleWrapper(item!, property).Value = newValue;
                                                                  await OnValueChange.InvokeAsync(null);
                                                              }) />
                                    }
                                    else if (propType == typeof(int))
                                    {
                                        <InputNumberComponent Value=@PropertyWrapperHelper.GetIntWrapper(item!, property).Value
                                                              ValueExpression=@(() => PropertyWrapperHelper.GetIntWrapper(item!, property).Value)
                                                              ViewMode=@ViewMode
                                                              ValueChanged=@(async (int newValue) =>
                                                              {
                                                                // To update and notify the parent view about the change
                                                                  PropertyWrapperHelper.GetIntWrapper(item!, property).Value = newValue;
                                                                  await OnValueChange.InvokeAsync(null);
                                                              }) />
                                    }
                                    else if (typeof(System.Collections.IEnumerable).IsAssignableFrom(propType) && propType != typeof(string) && propType.IsGenericType)
                                    {
                                        @foreach (var item in DataForSelects)
                                        {
                                            <span>A: @item.PropertyName</span>
                                        }
                                        var innerType = property.PropertyType.GetGenericArguments().First();
                                        if (DataForSelects.Any(x => x.PropertyType == innerType && x.PropertyName == property.Name))
                                        {
                                            <InputMultiSelectComponent TItem="object"
                                                                       @bind-SelectedItems="PropertyWrapperHelper.GetListWrapper(item!, property).Value"
                                                                       Items="DataForSelects.First(x => x.PropertyType == innerType && x.PropertyName == property.Name).Options"
                                                                       ViewMode="@ViewMode" />
                                        }
                                    }
                                    else if (propType.IsClass && propType != typeof(string))
                                    {
                                        if (DataForSelects.Any(x => x.PropertyType == propType && x.PropertyName == property.Name))
                                        {
                                            <InputSelectComponent @bind-SelectedItem=@(PropertyWrapperHelper.GetObjectWrapper(item!, property).Value)
                                                                  Items=@DataForSelects.First(x => x.PropertyType == propType && x.PropertyName == property.Name).Options
                                                                  ViewMode=@ViewMode />
                                        }
                                    }
                                    else
                                    {
                                        @ShowValue(item, property)
                                    }
                                </EditForm>
                            </td>
                        }
                        else
                        {
                            var propertyValue = property.GetValue(item);
                            if (propertyValue is bool data)
                            {
                                <td>
                                    <EditForm Model=propertyValue>
                                        <InputCheckBoxComponent @bind-Value=@PropertyWrapperHelper.GetBoolWrapper(item!, property).Value />
                                    </EditForm>
                                </td>
                            }
                            else if (property == Properties.FirstOrDefault() && OpenDetail.HasDelegate)
                            {
                                <td @onclick=@(x => OpenDetail.InvokeAsync(item))
                                    style="cursor:pointer; color: var(--primary);">
                                    @ShowValue(item, property)
                                </td>
                            }
                            else
                            {
                                <td>@ShowValue(item, property)</td>
                            }
                        }
                    }
                    @if (DeleteRowMethod.HasDelegate && ViewMode == ViewModeEnum.Edit)
                    {
                        <td class="td-delete">
                            <ButtonComponent OnClick=@(x => DeleteRowMethod.InvokeAsync(item))
                                             ButtonType=@ButtonTypeEnum.Delete
                                             IsVisible=@(ViewMode == ViewModeEnum.Edit ? true : false)
                                             NoDisplayName=true
                                             Tooltip="Delete this row"/>
                        </td>
                    }
                </tr>
            }
        }
        else
        {
        <td colspan="100%">
            <h5>No Records Found.</h5>
        </td>
        }
    </tbody>
</table>

@if (AddNewMethod.HasDelegate || FooterTools != null)
{
    <div class="row d-flex align-items-center">
        @if (AddNewMethod.HasDelegate)
        {
            <div class="col-auto">
                <ButtonComponent OnClick=@(async () => await AddNewMethod.InvokeAsync())
                                 ButtonType=@ButtonTypeEnum.Add
                                 ViewMode=@ViewMode />
            </div>
        }
        @if (FooterTools != null)
        {
            <div class="col">
                @FooterTools
            </div>
        }
    </div>
}


@code {
    #region Parameters
    #region Data
    /// <summary>
    ///DataSource to fill the data table
    /// </summary>
    [Parameter]
    public List<TItem> DataSource { get; set; } = new();

    /// <summary>
    /// Data used to fill in the exisitng selects on the table with the options from the DB.
    /// It needs a List<SelectOptionSet> that have the Model and the options of that Model, and the name given to that field.
    /// </summary>
    [Parameter]
    public List<SelectOptionSet> DataForSelects { get; set; } = new();

    /// <summary>
    /// Use to give custom names to the table heads.
    /// If no label given, it will automatically use the Property name and format it with spaces before uppercase letters
    /// </summary>
    [Parameter]
    public List<FieldNameConvertedModel> CustomTableHeadNames { get; set; } = new();
    #endregion

    #region OnClickMethods
    /// <summary>
    /// Not showing by default.
    /// If any method is passed, it will show the button and be executed when the delete button of the row is clicked.
    /// </summary>
    [Parameter]
    public EventCallback<TItem> DeleteRowMethod { get; set; } = new();

    /// <summary>
    /// Not showing by default.
    /// If any method is passed, it will show the button and be executed when the Add button is clicked.
    /// </summary>
    [Parameter]
    public EventCallback<TItem> AddNewMethod { get; set; } = new();

    /// <summary>
    /// Not active by default.
    /// If any method is passed, it will execute when user clicks on the first column of each row
    /// </summary>
    [Parameter]
    public EventCallback<TItem> OpenDetail { get; set; } = new();
    #endregion

    /// <summary>
    /// To update the parent when changes are made in some components
    /// </summary>
    [Parameter]
    public EventCallback OnValueChange { get; set; }

    /// <summary>
    /// Defines if the table will be used to only show data, or if it also be used to edit data.
    /// </summary>
    [Parameter]
    public bool IsEditableTable { get; set; } = false;

    [Parameter]
    public DateTime LimitDateInputsToThisDate { get; set; } = DateTime.Now;
    [Parameter]
    public bool IsDateInputLimitedToDate { get; set; } = true;

    /// <summary>
    /// Defines the Viewmode of the table.
    /// </summary>
    [Parameter]
    public ViewModeEnum ViewMode { get; set; } = ViewModeEnum.View;

    /// <summary>
    /// Render fragment for extra buttons on the footer of the table, disabled by default.
    /// </summary>
    [Parameter]
    public RenderFragment FooterTools { get; set; } = null!;

    /// <summary>
    /// Sets the date inputs to display Month and Year
    /// </summary>
    [Parameter] public string DateInputFormat { get; set; } = "Y";

    /// <summary>
    /// Properties assigned to not show their columns in the table
    /// </summary>
    [Parameter] public List<PropertyInfo> PropertiesNotShown { get; set; } = new();
    #endregion

    #region Properties
    private List<PropertyInfo> Properties { get; set; } = new();
    #endregion

    #region Task OnInitializedAsync()
    protected override Task OnInitializedAsync()
    {
        //Prevents the Guid field and the UserId of being rendered on the Data Table
        Properties = typeof(TItem).GetProperties().ToList();
        Properties.RemoveAll(p => p.Name == nameof(Tenantable.UserId)
                               || p.PropertyType == typeof(Guid));

        if (PropertiesNotShown.Any())
        {        
            foreach (var item in PropertiesNotShown)
            {
                Properties.RemoveAll(p => p.Name == item.Name);
            }
        }
        return base.OnInitializedAsync();
    }
    #endregion

    #region Actions
    #region string ShowValue(TItem item, PropertyInfo property)
    private string ShowValue(TItem item, PropertyInfo property)
    {
        var value = property.GetValue(item);

        // Handle Lists
        if (value is System.Collections.IEnumerable enumerable && value is not string)
        {
            string propertyToExtract = "Name";
            List<string> listItems = new();

            foreach (var obj in enumerable)
            {
                var extractedValue = obj?.GetType().GetProperty(propertyToExtract)?.GetValue(obj)?.ToString();
                if (extractedValue != null)
                {
                    listItems.Add(extractedValue);
                }
            }

            return listItems.Any() ? string.Join(", ", listItems) : string.Empty;
        }
        else if (value is DateTime data)
        {
            return data.ToString(DateInputFormat);
        }
        else if (value is DateTimeOffset dataOffset)
        {
            return dataOffset.ToString(DateInputFormat);
        }

        // If it's a complex object and not a string, try to extract a "Name" property
        else if (value != null && !(value is string) && !value.GetType().IsPrimitive)
        {
            var nameProp = value.GetType().GetProperty("Name");
            if (nameProp != null)
            {
                var nameValue = nameProp.GetValue(value);
                if (nameValue != null)
                {
                    return nameValue.ToString()!;
                }
            }
        }

        return value?.ToString() ?? string.Empty;
    }
    #endregion

    #region string GetFieldName(PropertyInfo property)
    private string GetFieldName(PropertyInfo property)
    {
        var match = CustomTableHeadNames.FirstOrDefault(x => x.FieldName == property.Name && !string.IsNullOrWhiteSpace(x.Label));

        return match?.Label ?? FormatStringWithSpaces(property.Name);
    }
    #endregion

    #region string FormatStringWithSpaces(string input)
    private string FormatStringWithSpaces(string input)
    {
        // Return as is, if fewer than 2 uppercase letters
        if (input.Count(char.IsUpper) < 2) return input;

        var result = new StringBuilder();
        bool firstUpperFound = false;

        foreach (char c in input)
        {
            if (char.IsUpper(c))
            {
                // Add space before uppercase letters except the first one
                if (firstUpperFound) result.Append(' ');

                firstUpperFound = true;
            }
            result.Append(c);
        }

        return result.ToString();
    }
    #endregion
    #endregion
}
